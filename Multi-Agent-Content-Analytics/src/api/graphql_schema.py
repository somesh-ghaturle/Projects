"""
GraphQL Schema and Resolvers for Multi-Agent Content Analytics
"""

import strawberry
from typing import List, Optional, Dict, Any
from datetime import datetime
import asyncio
import logging

from ..agents.agent_orchestrator import AgentOrchestrator

logger = logging.getLogger(__name__)

# Type Definitions

@strawberry.type
class AgentStatus:
    """Agent status information"""
    name: str
    initialized: bool
    status: str
    last_execution: Optional[str] = None
    error_count: int = 0

@strawberry.type
class ConfidenceScore:
    """Confidence score for analysis results"""
    agent_name: str
    score: float
    factors: List[str]

@strawberry.type
class ContentSummary:
    """High-level content summary"""
    content_type: str
    analysis_scope: List[str]
    key_findings: List[str]

@strawberry.type
class ScriptAnalysisResult:
    """Script analysis results"""
    plot_summary: Optional[str] = None
    estimated_runtime: Optional[str] = None
    character_count: int = 0
    themes: List[str] = strawberry.field(default_factory=list)
    dialogue_quality: Optional[str] = None
    pacing: Optional[str] = None
    structure_notes: List[str] = strawberry.field(default_factory=list)

@strawberry.type
class GenreClassificationResult:
    """Genre classification results"""
    primary_genre: str
    confidence: float
    secondary_genres: List[str] = strawberry.field(default_factory=list)
    genre_probabilities: Dict[str, float] = strawberry.field(default_factory=dict)
    classification_method: Optional[str] = None

@strawberry.type
class SentimentAnalysis:
    """Sentiment analysis results"""
    overall_sentiment: str
    positive_percent: float
    negative_percent: float
    neutral_percent: float
    emotion_scores: Dict[str, float] = strawberry.field(default_factory=dict)

@strawberry.type
class MarketingRecommendation:
    """Marketing recommendations"""
    campaign_themes: List[str] = strawberry.field(default_factory=list)
    target_demographics: List[str] = strawberry.field(default_factory=list)
    immediate_actions: List[str] = strawberry.field(default_factory=list)
    long_term_strategies: List[str] = strawberry.field(default_factory=list)
    budget_allocation: Dict[str, str] = strawberry.field(default_factory=dict)

@strawberry.type
class MarketingAnalysisResult:
    """Marketing analysis results"""
    sentiment_analysis: SentimentAnalysis
    key_themes: List[str] = strawberry.field(default_factory=list)
    engagement_metrics: Dict[str, float] = strawberry.field(default_factory=dict)
    recommendations: MarketingRecommendation = strawberry.field(default_factory=MarketingRecommendation)
    data_summary: Dict[str, Any] = strawberry.field(default_factory=dict)

@strawberry.type
class CrossAgentInsight:
    """Insights generated by combining multiple agent results"""
    insight_type: str
    description: str
    confidence: float
    supporting_data: Dict[str, Any] = strawberry.field(default_factory=dict)

@strawberry.type
class ContentAnalysisResult:
    """Complete content analysis result"""
    analysis_id: str
    timestamp: str
    content_summary: ContentSummary
    agents_used: List[str]
    script_analysis: Optional[ScriptAnalysisResult] = None
    genre_classification: Optional[GenreClassificationResult] = None
    marketing_analysis: Optional[MarketingAnalysisResult] = None
    cross_agent_insights: List[CrossAgentInsight] = strawberry.field(default_factory=list)
    confidence_scores: List[ConfidenceScore] = strawberry.field(default_factory=list)
    overall_recommendations: List[str] = strawberry.field(default_factory=list)

@strawberry.type
class SystemStatus:
    """Overall system status"""
    orchestrator_initialized: bool
    agents: List[AgentStatus]
    cache_size: int
    active_tasks: int
    system_health: str

# Input Types

@strawberry.input
class ContentData:
    """Input data for content analysis"""
    script_text: Optional[str] = None
    text_content: Optional[str] = None
    social_media_data: Optional[List[str]] = None
    metadata: Optional[Dict[str, Any]] = strawberry.field(default_factory=dict)

@strawberry.input
class AnalysisOptions:
    """Options for content analysis"""
    include_script_analysis: bool = True
    include_genre_classification: bool = True
    include_marketing_analysis: bool = True
    detailed_insights: bool = True
    cache_results: bool = True

# Resolvers

class ContentAnalyticsResolver:
    """GraphQL resolvers for content analytics"""
    
    def __init__(self):
        self.orchestrator = AgentOrchestrator()
        self._initialized = False
    
    async def _ensure_initialized(self):
        """Ensure orchestrator is initialized"""
        if not self._initialized:
            await self.orchestrator.initialize()
            self._initialized = True

@strawberry.type
class Query:
    """GraphQL Query root"""
    
    @strawberry.field
    async def system_status(self) -> SystemStatus:
        """Get overall system status"""
        resolver = ContentAnalyticsResolver()
        await resolver._ensure_initialized()
        
        try:
            status_data = await resolver.orchestrator.get_agent_status()
            
            # Convert agent status data
            agents = []
            for agent_name, agent_info in status_data.get("agents", {}).items():
                agents.append(AgentStatus(
                    name=agent_name,
                    initialized=agent_info.get("initialized", False),
                    status=agent_info.get("status", "unknown"),
                    last_execution=agent_info.get("last_execution"),
                    error_count=agent_info.get("error_count", 0)
                ))
            
            # Determine system health
            system_health = "healthy"
            if not status_data.get("orchestrator_initialized", False):
                system_health = "initializing"
            elif any(not agent.initialized for agent in agents):
                system_health = "degraded"
            elif any(agent.error_count > 5 for agent in agents):
                system_health = "unstable"
            
            return SystemStatus(
                orchestrator_initialized=status_data.get("orchestrator_initialized", False),
                agents=agents,
                cache_size=status_data.get("cache_size", 0),
                active_tasks=status_data.get("active_tasks", 0),
                system_health=system_health
            )
            
        except Exception as e:
            logger.error(f"Error getting system status: {str(e)}")
            return SystemStatus(
                orchestrator_initialized=False,
                agents=[],
                cache_size=0,
                active_tasks=0,
                system_health="error"
            )
    
    @strawberry.field
    async def analyze_content(
        self,
        content_data: ContentData,
        options: Optional[AnalysisOptions] = None
    ) -> ContentAnalysisResult:
        """Analyze content using multiple agents"""
        resolver = ContentAnalyticsResolver()
        await resolver._ensure_initialized()
        
        # Set default options
        if options is None:
            options = AnalysisOptions()
        
        try:
            # Prepare content data for orchestrator
            orchestrator_input = {}
            
            if content_data.script_text and options.include_script_analysis:
                orchestrator_input["script_text"] = content_data.script_text
            
            if content_data.text_content and options.include_genre_classification:
                orchestrator_input["text_content"] = content_data.text_content
            
            if content_data.social_media_data and options.include_marketing_analysis:
                orchestrator_input["social_media_data"] = content_data.social_media_data
            
            if content_data.metadata:
                orchestrator_input["metadata"] = content_data.metadata
            
            # Run analysis
            analysis_results = await resolver.orchestrator.analyze_content(orchestrator_input)
            
            # Convert results to GraphQL types
            return await _convert_analysis_results(analysis_results, options.detailed_insights)
            
        except Exception as e:
            logger.error(f"Error in content analysis: {str(e)}")
            
            # Return error result
            return ContentAnalysisResult(
                analysis_id=f"error_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                timestamp=datetime.now().isoformat(),
                content_summary=ContentSummary(
                    content_type="error",
                    analysis_scope=[],
                    key_findings=[f"Analysis failed: {str(e)}"]
                ),
                agents_used=[],
                overall_recommendations=["Please check input data and try again"]
            )

@strawberry.type
class Mutation:
    """GraphQL Mutation root"""
    
    @strawberry.field
    async def initialize_system(self) -> bool:
        """Initialize the agent orchestrator system"""
        try:
            resolver = ContentAnalyticsResolver()
            await resolver._ensure_initialized()
            return True
        except Exception as e:
            logger.error(f"Error initializing system: {str(e)}")
            return False
    
    @strawberry.field
    async def cleanup_system(self) -> bool:
        """Cleanup the agent orchestrator system"""
        try:
            resolver = ContentAnalyticsResolver()
            if resolver._initialized:
                await resolver.orchestrator.cleanup()
                resolver._initialized = False
            return True
        except Exception as e:
            logger.error(f"Error cleaning up system: {str(e)}")
            return False

# Helper Functions

async def _convert_analysis_results(
    analysis_results: Dict[str, Any],
    detailed_insights: bool = True
) -> ContentAnalysisResult:
    """Convert orchestrator results to GraphQL types"""
    
    # Extract content summary
    content_summary_data = analysis_results.get("content_summary", {})
    content_summary = ContentSummary(
        content_type=content_summary_data.get("content_type", "unknown"),
        analysis_scope=content_summary_data.get("analysis_scope", []),
        key_findings=content_summary_data.get("key_findings", [])
    )
    
    # Extract individual agent results
    individual_results = analysis_results.get("individual_results", {})
    
    # Script analysis
    script_analysis = None
    if "script_analysis" in individual_results:
        script_data = individual_results["script_analysis"]
        script_summary = script_data.get("summary", {})
        script_analysis_data = script_data.get("analysis", {})
        
        script_analysis = ScriptAnalysisResult(
            plot_summary=script_summary.get("plot"),
            estimated_runtime=script_analysis_data.get("estimated_runtime"),
            character_count=len(script_data.get("characters", [])),
            themes=script_data.get("themes", []),
            dialogue_quality=script_analysis_data.get("dialogue_quality"),
            pacing=script_data.get("structure", {}).get("pacing"),
            structure_notes=script_analysis_data.get("structure_notes", [])
        )
    
    # Genre classification
    genre_classification = None
    if "genre_classification" in individual_results:
        genre_data = individual_results["genre_classification"]
        primary_genre_data = genre_data.get("primary_genre", {})
        
        genre_classification = GenreClassificationResult(
            primary_genre=primary_genre_data.get("genre", "Unknown"),
            confidence=primary_genre_data.get("confidence", 0.0),
            secondary_genres=[g.get("genre", "") for g in genre_data.get("secondary_genres", [])],
            genre_probabilities=genre_data.get("all_probabilities", {}),
            classification_method=genre_data.get("classification_method")
        )
    
    # Marketing analysis
    marketing_analysis = None
    if "marketing_analysis" in individual_results:
        marketing_data = individual_results["marketing_analysis"]
        sentiment_data = marketing_data.get("sentiment_analysis", {})
        percentages = sentiment_data.get("percentages", {})
        recommendations_data = marketing_data.get("recommendations", {})
        
        sentiment_analysis = SentimentAnalysis(
            overall_sentiment=sentiment_data.get("overall_sentiment", "neutral"),
            positive_percent=percentages.get("positive_percent", 0.0),
            negative_percent=percentages.get("negative_percent", 0.0),
            neutral_percent=percentages.get("neutral_percent", 0.0),
            emotion_scores=sentiment_data.get("emotion_analysis", {})
        )
        
        marketing_recommendation = MarketingRecommendation(
            campaign_themes=recommendations_data.get("campaign_themes", []),
            target_demographics=recommendations_data.get("target_demographics", []),
            immediate_actions=recommendations_data.get("immediate_actions", []),
            long_term_strategies=recommendations_data.get("long_term_strategies", []),
            budget_allocation=recommendations_data.get("budget_allocation", {})
        )
        
        marketing_analysis = MarketingAnalysisResult(
            sentiment_analysis=sentiment_analysis,
            key_themes=marketing_data.get("key_themes", []),
            engagement_metrics=marketing_data.get("engagement_metrics", {}),
            recommendations=marketing_recommendation,
            data_summary=marketing_data.get("data_summary", {})
        )
    
    # Cross-agent insights (if detailed insights requested)
    cross_agent_insights = []
    if detailed_insights:
        insights_data = analysis_results.get("cross_agent_insights", {})
        for insight_type, insight_info in insights_data.items():
            if isinstance(insight_info, dict) and not insight_info.get("error"):
                cross_agent_insights.append(CrossAgentInsight(
                    insight_type=insight_type,
                    description=str(insight_info),
                    confidence=0.8,  # Default confidence
                    supporting_data=insight_info
                ))
    
    # Confidence scores
    confidence_scores = []
    confidence_data = analysis_results.get("confidence_scores", {})
    for agent_name, score in confidence_data.items():
        if agent_name != "overall" and isinstance(score, (int, float)):
            confidence_scores.append(ConfidenceScore(
                agent_name=agent_name,
                score=float(score),
                factors=[]  # Could be enhanced with detailed factors
            ))
    
    # Overall recommendations
    recommendations_data = analysis_results.get("recommendations", {})
    overall_recommendations = []
    for category, recs in recommendations_data.items():
        if isinstance(recs, list):
            overall_recommendations.extend(recs[:2])  # Limit to top 2 per category
    
    return ContentAnalysisResult(
        analysis_id=analysis_results.get("analysis_id", "unknown"),
        timestamp=analysis_results.get("timestamp", datetime.now().isoformat()),
        content_summary=content_summary,
        agents_used=analysis_results.get("agents_used", []),
        script_analysis=script_analysis,
        genre_classification=genre_classification,
        marketing_analysis=marketing_analysis,
        cross_agent_insights=cross_agent_insights,
        confidence_scores=confidence_scores,
        overall_recommendations=overall_recommendations[:10]  # Limit to top 10
    )

# Create GraphQL Schema
schema = strawberry.Schema(query=Query, mutation=Mutation)
